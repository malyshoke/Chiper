#ifndef AES_Chiph
#define AES_Chiph


/**
 *  Базовый тип данных обрабатываемый криптоалгоритмом.
 */
typedef unsigned char   byte;


/////////////////////////////////////////////////////////////////////////////

/**
 *  Класс обеспечивает шифрование блока данных
 *  по стандартам AES-128, AES-192 и AES-256.
 *
 *  @note
 *  При компиляции можно выбрать поддерживаемые варианты длины ключа
 *  задав любую комбинацию макросов #AES_128, #AES_192 и #AES_256.
 *  По умолчанию будут поддерживаться все возможные длины ключей.
 */
class   aes {

#if !defined(AES_128) && !defined(AES_192) && !defined(AES_256)
    /// Обеспечивает поддержку ключей длиной 128 бит.       @ingroup AES
#define AES_128     
/// Обеспечивает поддержку ключей длиной 192 бит.       @ingroup AES
#define AES_192
/// Обеспечивает поддержку ключей длиной 256 бит.       @ingroup AES
#define AES_256
#endif

/////////////////////////////////////////////////////////////////////////////

public:

    /**
     *  Значения, возвращаемые методами.
     *  Сигнализирует об успехе / ошибке.
     */
    enum   status {
        Ok = 0,    ///< нет ошибки.
        wrong_key_lenght = ~0    ///< неверная длина ключа.
    };

    /**
     *  Размер блока шифротекста в байтах.
     *  По стандарту фиксирован.
     *  Может быть использован во внешних алгоритмах
     *  вызывающих методы класса.
     */
    static const unsigned  block_size = 16;

    /**
     *  Шифрование блока данных.
     *  @note   Входной и выходной блоки могут совпадать !
     */
    void
        encrypt(
            const byte      in[block_size], ///< Входной блок данных.
            byte            out[block_size] ///< Выходной блок данных.  @see block_size
        );

    /**
     *  Расшифровывание блока данных.
     *  @note   Входной и выходной блоки могут совпадать !
     */
    void
        decrypt(
            const byte      in[block_size], ///< Входной блок данных.
            byte            out[block_size] ///< Выходной блок данных. @see block_size
        );

    /**
     *  Расширение ключа.
     *  Для (де)шифрации обязательно используется расширенный ключ.
     *  Необходимо вызвать метод перед первым encrypt() или decrypt()
     *  @note   Допустимые размеры ключа:
     *  128 бит (если определён макрос #AES_128),
     *  192 бит (если определён макрос #AES_192),
     *  256 бит (если определён макрос #AES_265).
     */
    status
        expand_key(
            const byte* key,            ///< Ключ.
            const unsigned  size            ///< Размер ключа в битах.
        );

    /////////////////////////////////////////////////////////////////////////////

protected:

    /**
     *  Количество раундов шифрования.
     *  Автоматически устанавливается в функции расширения ключа.
     */
    unsigned    rounds;

    /**
     *  Криптоалгоритм обрабатывает блоки по 4 байта.
     */
    typedef unsigned long   u32;

    /**
     *  Расширенные (раундовые) ключи.
     *  Используются непосредственно для (де)шифрации текста.
     */
    u32     encryption_round_key[64],
        decryption_round_key[64];

    /**
     *  Таблицы замен.
     */
    static  u32 s_box[256];     ///< Прямая замена
    static  u32 r_box[256];     ///< Обратная замена
    static  u32 ft[4][256];     ///< Расширенная прямая замена
    static  u32 rt[4][256];     ///< Расширенная обратная замена

    /**
     *  Формирует таблицы замен.
     */
    void inline
        init_tables();

    /**
     *  Образующий полином (базис) поля GF(2**8).
     *  определён так:     phi(x) = x**8 + x**4 + x**3 + x**1 + 1;
     */
    static const unsigned   basis = 1 << 8 | 1 << 4 | 1 << 3 | 1 << 1 | 1 << 0;

    /**
     *  Генератор Галуа (Linear Feedback Shift Register)
     *  ненулевых элементов поля GF(2**8) в заданном базисе.
     *  Выполняет умножение на x по модулю phi(x). (xTime)
     */
    byte static inline
        lfsr2(
            byte    a           ///< Предыдущее состойние генератора.
        );

    /**
     *  Циклический сдвиг двойного слова влево на байт.
     */
    u32 static inline
        rot_left_8(
            u32 value           ///< Сдвигаемое значение.
        );

    /**
     *  Преобразуете 4 байта в двойное слово (32бита).
     */
    u32 static inline
        get(
            const byte array[4] ///< Указатель на массив из 4-х байт.
        );

    /**
     *  Помещает двойное слово (32бита) в массив из четырёх байт.
     */
    void static inline
        put(
            u32  value,         ///< Исходные данные.
            byte array[4]       ///< Указатель на массив из четырёх байт. 
        );

    /**
     *  Вспомогательная функция прямой табличной замены.
     *  Один из байт двойного слова используется в качестве индекса.
     */
    u32 static inline
        fb(
            u32 byte,           ///< Слово содержащее байт.
            unsigned position   ///< Позиция байта в слове.
        );

    /**
     *  Вспомогательная функция обратной табличной замены.
     *  Один из байт двойного слова используется в качестве индекса.
     */
    u32 static inline
        rb(
            u32 byte,           ///< Слово содержащее байт.
            unsigned position   ///< Позиция байта в слове.
        );

};//class   aes

#endif

